import {type Module, inject} from "langium";
import type {LangiumServices, LangiumSharedServices, PartialLangiumServices} from "langium/lsp";
import {
    createDefaultModule,
    createDefaultSharedModule,
    type DefaultSharedModuleContext,
} from "langium/lsp";
import {
    StatemachineModelGeneratedModule,
    StatemachineGeneratedSharedModule,
} from "./generated/module.js";
import type {ValidationAcceptor, ValidationChecks} from "langium";
import type {State, Statemachine, StatemachineAstType, Event} from "./generated/ast.js";
import {MultiMap} from "langium";

export class StatemachineValidator {
    /**
     * Checks if the state name starts with a capital letter.
     * @param state the state to check
     * @param accept the acceptor to report errors
     */
    checkStateNameStartsWithCapital(state: State, accept: ValidationAcceptor): void {
        if (state.name) {
            const firstChar = state.name.substring(0, 1);
            if (firstChar.toUpperCase() !== firstChar) {
                accept("warning", "State name should start with a capital letter.", {
                    node: state,
                    property: "name",
                });
            }
        }
    }

    /**
     * Checks if there are duplicate state and event names.
     * @param statemachine the statemachine to check
     * @param accept the acceptor to report errors
     */
    checkUniqueStatesAndEvents(statemachine: Statemachine, accept: ValidationAcceptor): void {
        // check for duplicate state and event names and add them to the map
        const names = new MultiMap<string, State | Event>();
        const allSymbols = [...statemachine.states, ...statemachine.events];
        for (const symbol of allSymbols) {
            names.add(symbol.name, symbol);
        }
        for (const [name, symbols] of names.entriesGroupedByKey()) {
            if (symbols.length > 1) {
                for (const symbol of symbols) {
                    accept("error", `Duplicate identifier name: ${name}`, {
                        node: symbol,
                        property: "name",
                    });
                }
            }
        }
    }
}

/**
 * Declaration of custom services - add your own service classes here.
 */
export type StatemachineAddedServices = {
    validation: {
        StatemachineValidator: StatemachineValidator;
    };
};

/**
 * Union of Langium default services and your custom services - use this as constructor parameter
 * of custom service classes.
 */
export type StatemachineServices = LangiumServices & StatemachineAddedServices;

/**
 * Dependency injection module that overrides Langium default services and contributes the
 * declared custom services. The Langium defaults can be partially specified to override only
 * selected services, while the custom services must be fully specified.
 */
export const StatemachineModule: Module<
    StatemachineServices,
    PartialLangiumServices & StatemachineAddedServices
> = {
    validation: {
        StatemachineValidator: () => new StatemachineValidator(),
    },
};

/**
 * Create the full set of services required by Langium.
 *
 * First inject the shared services by merging two modules:
 *  - Langium default shared services
 *  - Services generated by langium-cli
 *
 * Then inject the language-specific services by merging three modules:
 *  - Langium default language-specific services
 *  - Services generated by langium-cli
 *  - Services specified in this file
 *
 * @param context Optional module context with the LSP connection
 * @returns An object wrapping the shared services and the language-specific services
 */
export function createStatemachineServices(context: DefaultSharedModuleContext): {
    shared: LangiumSharedServices;
    statemachine: StatemachineServices;
} {
    const shared = inject(createDefaultSharedModule(context), StatemachineGeneratedSharedModule);
    const statemachine = inject(
        createDefaultModule({shared}),
        StatemachineModelGeneratedModule,
        StatemachineModule,
    );
    shared.ServiceRegistry.register(statemachine);

    const registry = statemachine.validation.ValidationRegistry;
    const validator = statemachine.validation.StatemachineValidator;
    const checks: ValidationChecks<StatemachineAstType> = {
        State: validator.checkStateNameStartsWithCapital,
        Statemachine: validator.checkUniqueStatesAndEvents,
    };
    registry.register(checks, validator);

    if (!context.connection) {
        // We don't run inside a language server
        // Therefore, initialize the configuration provider instantly
        shared.workspace.ConfigurationProvider.initialized({});
    }
    return {shared, statemachine};
}

